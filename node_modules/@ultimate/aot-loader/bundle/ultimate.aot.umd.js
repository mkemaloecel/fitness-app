(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('path'), require('magic-string'), require('source-map'), require('typescript'), require('@angular/compiler'), require('fs'), require('@angular/compiler-cli'), require('vm')) :
    typeof define === 'function' && define.amd ? define(['exports', 'path', 'magic-string', 'source-map', 'typescript', '@angular/compiler', 'fs', '@angular/compiler-cli', 'vm'], factory) :
    (factory((global.ultimate = global.ultimate || {}, global.ultimate.aot = global.ultimate.aot || {}),global.path,global.MagicString,global.sourceMap,global.ts,global._angular_compiler,global.fs,global._angular_compilerCli,global.vm));
}(this, (function (exports,path,MagicString,sourceMap,typescript,_angular_compiler,fs,_angular_compilerCli,vm) { 'use strict';

    MagicString = 'default' in MagicString ? MagicString['default'] : MagicString;

    function findNodes(node, kind, sourceFile, recursive) {
        if (sourceFile === void 0) { sourceFile = node; }
        if (recursive === void 0) { recursive = false; }
        var nodes = [];
        if (node.kind === kind) {
            if (!recursive) {
                return [node];
            }
            nodes.push(node);
        }
        for (var _i = 0, _a = node.getChildren(sourceFile); _i < _a.length; _i++) {
            var child = _a[_i];
            var childNodes = findNodes(child, kind, sourceFile, recursive);
            for (var i = 0; i < childNodes.length; i++) {
                nodes.push(childNodes[i]);
            }
        }
        return nodes;
    }
    function filterDuplicates(arr) {
        return Array.from(new Set(arr)).slice();
    }
    function flatten(arr) {
        return arr.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []);
    }
    function getDecorator(node) {
        return node.expression.expression.text;
    }

    function getInitializer(node) {
        return node.initializer.text;
    }
    function getModule(dec) {
        return dec.moduleSpecifier.text;
    }
    function getName(node) {
        return node.propertyName ? node.propertyName.text : node.name.text;
    }

    function getPropertyAssignments(sourceFile) {
        var properties = findNodes(sourceFile, typescript.SyntaxKind.ObjectLiteralExpression, sourceFile, true)
            .map(function (node) { return findNodes(node, typescript.SyntaxKind.PropertyAssignment, sourceFile); });
        return flatten(properties);
    }





    function normalizePath(_a) {
        var text = _a.text;
        return (text[0] !== '.' ? "./" + text : text).replace(/\/\//g, '/');
    }
    function removeUnnamedImports(_a) {
        var c = _a.importClause;
        return !(c && !c.name && c.namedBindings) && c.namedBindings.kind === typescript.SyntaxKind.NamedImports;
    }

    function byPropertyName(name) {
        return function (node) { return node.name.text === name; };
    }



    function objToMap(obj) {
        return Object.keys(obj).reduce(function (a, b) { return a.set(b, obj[b]); }, new Map());
    }

    var __assign = (this && this.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var loadChildrenTemplate = function (_a) {
        var p = _a[0], m = _a[1];
        return "loadChildren:()=>__TROPMI__('" + p + ".ngfactory').then((r)=>r." + m + "NgFactory)";
    };
    var EXT = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    var TransformFile = (function () {
        function TransformFile(resourcePath, source, aotPlugin, generateSourceMap, sourceFile) {
            this.resourcePath = resourcePath;
            this.source = source;
            this.aotPlugin = aotPlugin;
            this.generateSourceMap = generateSourceMap;
            this.sourceFile = sourceFile;
            this.edited = false;
            if (!sourceFile) {
                this.sourceFile = typescript.createSourceFile(this.resourcePath, this.source, typescript.ScriptTarget.Latest);
            }
            this.sourceString = this.sourceFile.getFullText(this.sourceFile);
            this.sourceText = new MagicString(this.sourceString);
        }
        TransformFile.prototype.convertBootstrap = function (moduleName) {
            var _this = this;
            var calls = findNodes(this.sourceFile, typescript.SyntaxKind.CallExpression, this.sourceFile, true);
            var bootstraps = calls
                .filter(function (node) { return node.expression.kind === typescript.SyntaxKind.PropertyAccessExpression; })
                .map(function (node) { return node.expression; });
            var bootstrappedModules = bootstraps
                .filter(function (expression) { return expression.name.kind === typescript.SyntaxKind.Identifier; })
                .filter(function (expression) { return expression.name.text === 'bootstrapModule'; });
            bootstrappedModules.forEach(function (bootstrap) { return _this.replaceNode(bootstrap.name, 'bootstrapModuleFactory'); });
            bootstraps
                .reduce(function (previous, next) { return previous.concat(findNodes(next, typescript.SyntaxKind.CallExpression, _this.sourceFile)); }, [])
                .filter(function (call) { return call.expression.kind === typescript.SyntaxKind.Identifier; })
                .filter(function (call) { return call.expression.text === 'platformBrowserDynamic'; })
                .forEach(function (call) { return _this.replaceNode(call.expression, 'platformBrowser'); });
            calls
                .filter(function (call) { return bootstrappedModules.some(function (bootstrap) { return bootstrap === call.expression; }); })
                .forEach(function (call) { return _this.replaceNode(call.arguments[0], moduleName + 'NgFactory'); });
        };
        TransformFile.prototype.convertLoadChildren = function (basePath, genDir) {
            var assignments = getPropertyAssignments(this.sourceFile)
                .filter(byPropertyName('loadChildren'));
            for (var _i = 0, assignments_1 = assignments; _i < assignments_1.length; _i++) {
                var node = assignments_1[_i];
                var _a = getInitializer(node).split('#'), path$$1 = _a[0], module_1 = _a[1];
                var dirName = path.normalize(path.dirname(this.resourcePath));
                var genRelativeToBase = path.relative(basePath, genDir);
                var fileRelativeToBase = path.relative(basePath, dirName);
                var genRelativeToFile = path.relative(fileRelativeToBase, genRelativeToBase);
                var genToFile = path.join(genRelativeToFile, path.relative(basePath, path$$1).replace(EXT, ''));
                var factoryPath = './' + genToFile.replace(/\\/g, '/');
                this.replaceNode(node, loadChildrenTemplate([factoryPath, module_1]));
            }
        };
        TransformFile.prototype.convertImport = function (from, to) {
            var imports = findNodes(this.sourceFile, typescript.SyntaxKind.ImportDeclaration);
            var fromImports = imports
                .filter(function (dec) { return dec.moduleSpecifier.kind === typescript.SyntaxKind.StringLiteral; })
                .filter(function (dec) { return dec.moduleSpecifier.text === from.module; })
                .filter(removeUnnamedImports);
            var needsImport = true;
            if (fromImports.length) {
                for (var i = 0; i < fromImports.length; i++) {
                    var fromImport = fromImports[i];
                    var namedBindings = fromImport.importClause.namedBindings;
                    var elements = namedBindings.elements;
                    if (elements.some(function (element) { return element.name.text === from.name; })) {
                        if (elements.length > 1) {
                            var start = 0;
                            var end = 0;
                            for (var n = 0; n < elements.length; n++) {
                                var element = elements[n];
                                if (element.name.text === from.name) {
                                    start = (n > 0) ? elements[n - 1].getEnd() : element.getStart(this.sourceFile);
                                    end = (n > 0) ? element.getEnd() : elements[n + 1].getStart(this.sourceFile);
                                    break;
                                }
                            }
                            this.sourceText.overwrite(start, end, '');
                        }
                        else {
                            needsImport = false;
                            this.replaceNode(fromImport.moduleSpecifier, "'" + to.module + "'");
                            this.replaceNode(elements[0], to.name);
                            break;
                        }
                    }
                }
            }
            if (needsImport) {
                var toImports = imports
                    .filter(function (dec) { return dec.moduleSpecifier.kind === typescript.SyntaxKind.StringLiteral; })
                    .filter(function (dec) { return dec.moduleSpecifier.text === to.module; })
                    .filter(removeUnnamedImports);
                if (toImports.length) {
                    for (var i = 0; i < toImports.length; i++) {
                        var toImport = toImports[i];
                        var namedBindings = toImport.importClause.namedBindings;
                        var elements = namedBindings.elements;
                        var hasImport = elements.some(function (element) { return element.name.text === to.name; });
                        if (hasImport) {
                            break;
                        }
                        this.sourceText.prependRight(elements[elements.length - 1].getEnd(), ", " + to.name);
                    }
                }
                else {
                    this.sourceText.prependRight(imports[imports.length - 1].getEnd(), "import {" + to.name + "} from '" + to.module + "';");
                }
            }
        };
        TransformFile.prototype.getResources = function () {
            var properties = getPropertyAssignments(this.sourceFile);
            var resources = [];
            var styleUrlsProperty = properties.find(byPropertyName('styleUrls'));
            if (styleUrlsProperty) {
                resources = resources.concat(styleUrlsProperty.initializer.elements);
            }
            var templateUrlProperty = properties.find(byPropertyName('templateUrl'));
            if (templateUrlProperty) {
                resources.push(templateUrlProperty.initializer);
            }
            return resources.map(normalizePath);
        };
        TransformFile.prototype.removeDecorators = function () {
            var imports = findNodes(this.sourceFile, typescript.SyntaxKind.ImportDeclaration)
                .filter(function (node) { return node.moduleSpecifier.kind === typescript.SyntaxKind.StringLiteral; })
                .filter(function (node) { return getModule(node).startsWith('@angular/'); })
                .filter(function (node) { return node.importClause && !node.importClause.name && node.importClause.namedBindings; })
                .map(function (node) { return node.importClause.namedBindings; });
            var namespaceImports = imports
                .filter(function (node) { return node.kind === typescript.SyntaxKind.NamespaceImport; })
                .map(function (node) { return node.name.text + '.'; });
            var namedImports = imports
                .filter(function (node) { return node.kind === typescript.SyntaxKind.NamedImports; })
                .map(function (node) { return node.elements; })
                .map(function (elements) { return elements.map(getName); });
            var angularImports = flatten(namedImports.concat(namespaceImports));
            if (!angularImports.length) {
                return;
            }
            function isAngularImport(node) {
                var decorator = node.expression.text;
                if (decorator.includes('.')) {
                    return angularImports.includes(decorator.replace(/\..*$/, '') + '.');
                }
                return angularImports.includes(decorator);
            }
            var decorators = findNodes(this.sourceFile, typescript.SyntaxKind.Decorator);
            for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
                var node = decorators_1[_i];
                var expressions = findNodes(node, typescript.SyntaxKind.CallExpression).filter(isAngularImport);
                for (var _a = 0, expressions_1 = expressions; _a < expressions_1.length; _a++) {
                    var expr = expressions_1[_a];
                    this.removeNode(node);
                }
            }
        };
        TransformFile.prototype.removeNode = function (node) {
            this.edited = true;
            this.sourceText.remove(node.getStart(this.sourceFile), node.getEnd());
        };
        TransformFile.prototype.replaceNode = function (node, contents) {
            this.edited = true;
            var store = node.kind === typescript.SyntaxKind.Identifier;
            this.sourceText.overwrite(node.getStart(this.sourceFile), node.getEnd(), contents, store);
        };
        TransformFile.prototype.transpile = function () {
            var result = typescript.transpileModule(this.sourceText.toString(), {
                compilerOptions: __assign({}, this.aotPlugin.parsedConfig.options, { inlineSources: true, inlineSourceMap: false, sourceMap: true, sourceRoot: this.aotPlugin.parsedConfig.options.baseUrl }),
                fileName: this.resourcePath
            });
            var sourceMap$$1 = JSON.parse(result.sourceMapText);
            if (this.edited && this.generateSourceMap) {
                var consumer = new sourceMap.SourceMapConsumer(sourceMap$$1);
                var generator = sourceMap.SourceMapGenerator.fromSourceMap(consumer);
                var textSourceMap = this.sourceText.generateMap({
                    file: path.basename(this.resourcePath.replace(/\.ts$/, '.js')),
                    source: this.resourcePath,
                    includeAll: true
                });
                generator.applySourceMap(new sourceMap.SourceMapConsumer(textSourceMap), this.resourcePath);
                sourceMap$$1 = generator.toJSON();
                sourceMap$$1.sources = [this.resourcePath];
                sourceMap$$1.file = path.basename(this.resourcePath, '.ts') + '.js';
                sourceMap$$1.sourcesContent = [this.sourceString];
            }
            return {
                outputText: result.outputText,
                sourceMap: sourceMap$$1
            };
        };
        return TransformFile;
    }());

    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve$$1, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve$$1(result.value) : new P(function (resolve$$1) { resolve$$1(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
        return { next: verb(0), "throw": verb(1), "return": verb(2) };
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    function aotLoader$1(source, map) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var callback, aotPlugin, err_1, sourceFile, isGenerated, transformFile, angularCompilerOptions, basePath, genDir, dirName, genRelativeToBase, fileRelativeToBase, genRelativeToFile, entryModule, genToEntryFile, fileToEntryFile, normalPath, factoryPath, resources, i, transpiledModule, sourceMap$$1, compiledSource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.cacheable();
                        callback = this.async();
                        aotPlugin = this._compilation.aotPlugin;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, aotPlugin.compilePromise];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        return [2 /*return*/, callback(null, '')];
                    case 4:
                        if (aotPlugin.sourceFileCache.has(this.resourcePath)) {
                            sourceFile = aotPlugin.sourceFileCache.get(this.resourcePath);
                        }
                        isGenerated = /\.(ngfactory|ngstyle)(\.|$)/.test(this.resourcePath);
                        transformFile = new TransformFile(this.resourcePath, source, aotPlugin, !isGenerated, sourceFile);
                        angularCompilerOptions = aotPlugin.tsConfig.angularCompilerOptions;
                        basePath = path.normalize(angularCompilerOptions.basePath);
                        genDir = path.normalize(angularCompilerOptions.genDir);
                        if (source.match(/bootstrapModule/ig)) {
                            dirName = path.normalize(path.dirname(this.resourcePath));
                            genRelativeToBase = path.relative(basePath, genDir);
                            fileRelativeToBase = path.relative(basePath, dirName);
                            genRelativeToFile = path.relative(fileRelativeToBase, genRelativeToBase);
                            entryModule = aotPlugin.entryModule;
                            genToEntryFile = path.join(genRelativeToFile, entryModule.path + '.ngfactory');
                            fileToEntryFile = path.join(fileRelativeToBase, entryModule.path);
                            normalPath = './' + fileToEntryFile.replace(/\\/g, '/');
                            factoryPath = './' + genToEntryFile.replace(/\\/g, '/');
                            transformFile.convertBootstrap(entryModule.module);
                            transformFile.convertImport({ name: 'platformBrowserDynamic', module: '@angular/platform-browser-dynamic' }, { name: 'platformBrowser', module: '@angular/platform-browser' });
                            transformFile.convertImport({ name: entryModule.module, module: normalPath }, { name: entryModule.module + "NgFactory", module: factoryPath });
                        }
                        if (/\.ngfactory(\.|$)/.test(this.resourcePath) && /loadChildren/.test(source)) {
                            transformFile.convertLoadChildren(basePath, genDir);
                        }
                        if (!/\.ngfactory(\.|$)/.test(this.resourcePath)) {
                            transformFile.removeDecorators();
                        }
                        if (/templateUrl/.test(source) || /styleUrls/.test(source)) {
                            resources = transformFile
                                .getResources()
                                .map(function (resource) { return path.resolve(path.dirname(_this.resourcePath), resource); });
                            for (i = 0; i < resources.length; i++) {
                                this.addDependency(resources[i]);
                            }
                            aotPlugin.registerResources(this.resourcePath, resources);
                        }
                        transpiledModule = transformFile.transpile();
                        sourceMap$$1 = transpiledModule.sourceMap;
                        compiledSource = transpiledModule.outputText.replace(/__TROPMI__/g, 'import');
                        callback(null, compiledSource, sourceMap$$1);
                        return [2 /*return*/];
                }
            });
        });
    }

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var dev = Math.floor(Math.random() * 100000);
    var Stats = (function () {
        function Stats(name) {
            this.name = name;
            this.atime = new Date();
            this.blksize = 512;
            this.btime = new Date();
            this.ctime = new Date();
            this.dev = dev;
            this.gid = process.env['GID'] || 0;
            this.ino = Math.floor(Math.random() * 100000);
            this.mtime = new Date();
            this.nlink = 1;
            this.rdev = 0;
            this.uid = process.env['UID'] || 0;
            this.size = 0;
        }
        Stats.prototype.isFile = function () { return false; };
        Stats.prototype.isDirectory = function () { return false; };
        Stats.prototype.isBlockDevice = function () { return false; };
        Stats.prototype.isCharacterDevice = function () { return false; };
        Stats.prototype.isSymbolicLink = function () { return false; };
        Stats.prototype.isFIFO = function () { return false; };
        Stats.prototype.isSocket = function () { return false; };
        Object.defineProperty(Stats.prototype, "blocks", {
            get: function () {
                return Math.ceil(this.size / this.blksize);
            },
            enumerable: true,
            configurable: true
        });
        return Stats;
    }());
    var File = (function (_super) {
        __extends(File, _super);
        function File(name, contents) {
            var _this = _super.call(this, name) || this;
            _this.contents = contents;
            _this._size = 0;
            return _this;
        }
        Object.defineProperty(File.prototype, "content", {
            get: function () {
                return this.contents;
            },
            set: function (content) {
                this.mtime = new Date();
                this.contents = content;
            },
            enumerable: true,
            configurable: true
        });
        File.prototype.getSourceFile = function (languageVersion, setParentNodes) {
            if (!this.sourceFile) {
                this.sourceFile = typescript.createSourceFile(this.name, this.contents, languageVersion, setParentNodes);
            }
            return this.sourceFile;
        };
        File.prototype.isFile = function () {
            return true;
        };
        Object.defineProperty(File.prototype, "size", {
            get: function () {
                return this.contents ? this.contents.length : this._size;
            },
            set: function (size) {
                this._size = size;
            },
            enumerable: true,
            configurable: true
        });
        return File;
    }(Stats));
    var Directory = (function (_super) {
        __extends(Directory, _super);
        function Directory(name) {
            var _this = _super.call(this, name) || this;
            _this.size = 1024;
            return _this;
        }
        Directory.prototype.isDirectory = function () {
            return true;
        };
        return Directory;
    }(Stats));

    var isWindows = process.platform.startsWith('win');
    var Host = (function () {
        function Host(options, basePath) {
            this.options = options;
            this.basePath = basePath;
            this.directories = {};
            this.host = typescript.createCompilerHost(this.options, true);
            this.files = {};
        }
        Host.prototype.directoryExists = function (directoryName) {
            return !!this.directories[directoryName] || this.host.directoryExists(directoryName);
        };
        Host.prototype.fileExists = function (fileName) {
            if (!fs.existsSync(fileName)) {
                delete this.files[fileName];
                return false;
            }
            return !!this.files[fileName] || this.host.fileExists(fileName);
        };
        Host.prototype.getCanonicalFileName = function (fileName) {
            return this.host.getCanonicalFileName(fileName);
        };
        Host.prototype.getCurrentDirectory = function () {
            return this.basePath;
        };
        Host.prototype.getDefaultLibFileName = function (options) {
            return this.host.getDefaultLibFileName(options);
        };
        Host.prototype.getDirectories = function (path$$1) {
            path$$1 = this.resolveFileName(path$$1);
            var directories;
            try {
                directories = this.host.getDirectories(path$$1);
            }
            catch (e) {
                directories = [];
            }
            var directoryKeys = Object.keys(this.directories);
            var subDirectories = directoryKeys
                .filter(function (directory) { return path.dirname(directory) === path$$1; })
                .map(function (path$$1) { return path.basename(path$$1); });
            return directories.concat(subDirectories);
        };
        Host.prototype.getFiles = function (path$$1) {
            path$$1 = this.resolveFileName(path$$1);
            return Object.keys(this.files)
                .filter(function (fileName) { return path.dirname(fileName) === path$$1; })
                .map(function (path$$1) { return path.basename(path$$1); });
        };
        Host.prototype.getNewLine = function () {
            return this.host.getNewLine();
        };
        Host.prototype.getSourceFile = function (fileName, languageVersion, onError) {
            fileName = this.resolveFileName(fileName);
            if (this.files[fileName]) {
                return this.files[fileName].getSourceFile(languageVersion, true);
            }
            return this.host.getSourceFile(fileName, languageVersion, onError);
        };
        Host.prototype.readFile = function (fileName) {
            fileName = this.resolveFileName(fileName);
            if (this.files[fileName]) {
                return this.files[fileName].content;
            }
            return this.host.readFile(fileName);
        };
        Host.prototype.resolveFileName = function (fileName) {
            var path$$1 = fileName.replace(/\\/g, '/');
            if (path$$1[0] === '.') {
                return path.join(this.getCurrentDirectory(), path$$1);
            }
            if (path$$1[0] === '/' || path$$1.match(/^\w:\//)) {
                return path$$1;
            }
            return path.join(this.basePath, path$$1);
        };
        Host.prototype.useCaseSensitiveFileNames = function () {
            return this.host.useCaseSensitiveFileNames();
        };
        Object.defineProperty(Host.prototype, "writeFile", {
            get: function () {
                var _this = this;
                return function (fileName, data) {
                    fileName = _this.resolveFileName(fileName);
                    _this.files[fileName] = new File(fileName, data);
                    var path$$1 = path.dirname(fileName);
                    var paths = [];
                    while (path$$1 && !_this.directories[path$$1]) {
                        paths.push(path$$1);
                        _this.directories[path$$1] = new Directory(path$$1);
                        path$$1 = path.dirname(path$$1);
                    }
                    var fileSystem = _this.compiler.resolvers.normal.fileSystem;
                    var filePath = isWindows ? fileName.replace(/\//g, '\\') : fileName;
                    fileSystem._statStorage.data[filePath] = [null, _this.files[fileName]];
                    fileSystem._readFileStorage.data[filePath] = [null, _this.files[fileName].content];
                    for (var i = 0; i < paths.length; i++) {
                        var dirName = paths[i];
                        var stats = _this.directories[dirName];
                        var dirs = _this.getDirectories(dirName);
                        var files = _this.getFiles(dirName);
                        var dirPath = isWindows ? dirName.replace(/\//g, '\\') : dirName;
                        fileSystem._statStorage.data[dirPath] = [null, stats];
                        fileSystem._readdirStorage.data[dirPath] = [null, files.concat(dirs)];
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        return Host;
    }());

    var __extends$1 = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __awaiter$2 = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve$$1, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve$$1(result.value) : new P(function (resolve$$1) { resolve$$1(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$2 = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
        return { next: verb(0), "throw": verb(1), "return": verb(2) };
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');
    var AotContext = (function (_super) {
        __extends$1(AotContext, _super);
        function AotContext(host) {
            var _this = _super.call(this, host) || this;
            _this.childCompilers = {};
            _this.context = vm.createContext(Object.assign({ require: require }, global));
            _this.resourceExtensions = [];
            _this.compiling = false;
            return _this;
        }
        AotContext.prototype.compileResource = function (fileName) {
            var _this = this;
            if (!this.childCompilers[fileName]) {
                this.childCompilers[fileName] = this.compilation.createChildCompiler(fileName, { filename: fileName });
                this.childCompilers[fileName].context = this.compiler.context;
                this.childCompilers[fileName].apply(new SingleEntryPlugin(this.childCompilers[fileName].context, fileName, fileName));
            }
            var existsInParent = this.compilation.assets[fileName];
            var childCompiler = this.childCompilers[fileName];
            childCompiler.plugin('compilation', function (compilation) {
                if (compilation.cache) {
                    if (!compilation.cache[fileName]) {
                        compilation.cache[fileName] = {};
                    }
                    compilation.cache = compilation.cache[fileName];
                }
            });
            this.compiling = true;
            return new Promise(function (resolve$$1) {
                childCompiler.runAsChild(function (err, entries, childCompilation) {
                    if (err) {
                        childCompilation.errors.push(err);
                        return resolve$$1();
                    }
                    if (!existsInParent) {
                        delete _this.compilation.assets[fileName];
                    }
                    _this.compiling = false;
                    resolve$$1(childCompilation.assets[fileName].source());
                });
            });
        };
        AotContext.prototype.readResource = function (fileName) {
            return __awaiter$2(this, void 0, void 0, function () {
                var fileExtension, source, script, result, err;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            fileExtension = path.extname(fileName);
                            if (!this.resourceExtensions.includes(fileExtension)) {
                                this.resourceExtensions.push(fileExtension);
                            }
                            return [4 /*yield*/, this.compileResource(fileName)];
                        case 1:
                            source = _a.sent();
                            try {
                                script = new vm.Script(source, { filename: fileName });
                                result = script.runInContext(this.context);
                                if (typeof result !== 'string') {
                                    err = 'templateUrl and styleUrls need to be loaded as a string when using AoT compilation';
                                    throw new Error(err + "\nAsset " + fileName + " exported '" + typeof result + "' (try using raw-loader as the last loader)");
                                }
                                return [2 /*return*/, result];
                            }
                            catch (err) {
                                throw err;
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        return AotContext;
    }(_angular_compilerCli.ModuleResolutionHostAdapter));

    var __extends$2 = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AotCompilerHost = (function (_super) {
        __extends$2(AotCompilerHost, _super);
        function AotCompilerHost(program, options, context, sourceFileCache) {
            var _this = _super.call(this, program, options, context) || this;
            _this.program = program;
            _this.options = options;
            _this.context = context;
            _this.sourceFileCache = sourceFileCache;
            return _this;
        }
        AotCompilerHost.prototype.getSourceFile = function (fileName) {
            if (this.sourceFileCache.has(fileName)) {
                return this.sourceFileCache.get(fileName);
            }
            return _super.prototype.getSourceFile.call(this, fileName);
        };
        return AotCompilerHost;
    }(_angular_compilerCli.CompilerHost));

    var __awaiter$1 = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve$$1, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve$$1(result.value) : new P(function (resolve$$1) { resolve$$1(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$1 = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
        return { next: verb(0), "throw": verb(1), "return": verb(2) };
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var FILE_EXTENSION = /\.[^/.]+$/;
    var INJECTOR = /(\w+?)Injector/;
    var AotPlugin = (function () {
        function AotPlugin(config) {
            this.config = config;
            this.files = [];
            // dependencies
            this.componentDependencies = new Map();
            this.moduleDependencies = new Map();
            this.parentDependencies = new Map();
            // misc
            this.compilePromise = Promise.resolve();
            this.ranInitialCompile = false;
            // timing
            this.prevTimestamps = new Map();
            this.startTime = Date.now();
            // resources
            this.resources = new Map();
            this.resourcesDependencies = new Map();
            // cache
            this.sourceFileCache = new Map();
            this.symbols = [];
            if (!config.tsConfig) {
                throw new Error('tsconfig.json is required');
            }
            var tsConfigPath = path.resolve(process.cwd(), config.tsConfig);
            try {
                this.tsConfig = JSON.parse(typescript.sys.readFile(tsConfigPath));
            }
            catch (err) {
                throw new Error("Error parsing tsconfig.json: " + err);
            }
            this.parsedConfig = typescript.parseJsonConfigFileContent(this.tsConfig, typescript.sys, path.dirname(tsConfigPath), null, tsConfigPath);
            var angularCompilerOptions = this.tsConfig.angularCompilerOptions || {};
            angularCompilerOptions.basePath = angularCompilerOptions.basePath || path.dirname(tsConfigPath);
            angularCompilerOptions.genDir = path.join(angularCompilerOptions.basePath, angularCompilerOptions.genDir || '__generated');
            if (config.entryModule) {
                angularCompilerOptions.entryModule = config.entryModule;
            }
            this.tsConfig.angularCompilerOptions = angularCompilerOptions;
            var _a = angularCompilerOptions.entryModule.split('#'), path$$1 = _a[0], module = _a[1];
            this.entryModule = { path: path$$1, module: module };
            this.host = new Host(this.parsedConfig.options, angularCompilerOptions.basePath);
            this.context = new AotContext(this.host);
            this.program = typescript.createProgram(this.parsedConfig.fileNames, this.parsedConfig.options, this.host, this.program);
            this.ngCompilerHost = new AotCompilerHost(this.program, angularCompilerOptions, this.context, this.sourceFileCache);
            this.aotCompiler = _angular_compiler.createAotCompiler(this.ngCompilerHost, {});
        }
        AotPlugin.prototype.apply = function (compiler) {
            var _this = this;
            this.context.compiler = compiler;
            this.host.compiler = compiler;
            // compiler.watchFileSystem.watcher
            var errors = [];
            compiler.plugin('make', function (compilation, callback) { return __awaiter$1(_this, void 0, void 0, function () {
                var _this = this;
                var err_1, changedFiles, extraFiles, _i, changedFiles_1, changedFile, files, err_2;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            errors = [];
                            compilation.aotPlugin = this;
                            this.context.compilation = compilation;
                            this.host.compilation = compilation;
                            if (!!this.ranInitialCompile) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            this.createSourceFiles(this.parsedConfig.fileNames, compilation);
                            this.compilePromise = this.compileFiles(this.parsedConfig.fileNames);
                            return [4 /*yield*/, this.compilePromise];
                        case 2:
                            _a.sent();
                            this.ranInitialCompile = true;
                            return [3 /*break*/, 4];
                        case 3:
                            err_1 = _a.sent();
                            errors.push(err_1);
                            return [3 /*break*/, 4];
                        case 4:
                            changedFiles = Object.keys(compilation.fileTimestamps)
                                .filter(function (file) { return (_this.prevTimestamps.get(file) || _this.startTime) < (compilation.fileTimestamps[file] || Infinity); });
                            extraFiles = [];
                            for (_i = 0, changedFiles_1 = changedFiles; _i < changedFiles_1.length; _i++) {
                                changedFile = changedFiles_1[_i];
                                if (this.resources.has(changedFile)) {
                                    extraFiles = filterDuplicates(extraFiles.concat(this.resources.get(changedFile)));
                                }
                            }
                            changedFiles = changedFiles
                                .filter(function (file) { return !_this.resources.has(file); })
                                .concat(extraFiles);
                            this.prevTimestamps = new Map(objToMap(compilation.fileTimestamps));
                            files = changedFiles.length ? changedFiles : this.parsedConfig.fileNames;
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 8, , 9]);
                            this.createSourceFiles(files, compilation);
                            if (!changedFiles.length) return [3 /*break*/, 7];
                            // compile files if we've got newly updated files
                            this.compilePromise = this.compileFiles(changedFiles);
                            return [4 /*yield*/, this.compilePromise];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7: return [3 /*break*/, 9];
                        case 8:
                            err_2 = _a.sent();
                            errors.push(err_2);
                            return [3 /*break*/, 9];
                        case 9:
                            callback();
                            return [2 /*return*/];
                    }
                });
            }); });
            compiler.plugin('after-emit', function (compilation, callback) {
                if (errors.length) {
                    // add files to the file dependencies so webpack watches them
                    compilation.fileDependencies = compilation.fileDependencies.concat(_this.files);
                    compilation.errors = compilation.errors.concat(errors);
                }
                callback();
            });
            compiler.plugin('after-resolvers', function (compiler) {
                compiler.resolvers.normal.plugin('before-resolve', function (request, callback) { return __awaiter$1(_this, void 0, void 0, function () {
                    var requestExtension, isNativeModule, isNodeModule, isResource, isCompiling, err_3;
                    return __generator$1(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                requestExtension = path.extname(request.request);
                                isNativeModule = request.request.charAt(0) !== '.';
                                isNodeModule = /node_modules/.test(request.request);
                                isResource = this.context.resourceExtensions.includes(requestExtension);
                                isCompiling = this.context.compiling;
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 4, 5, 6]);
                                if (!(!isCompiling && !isResource && !isNativeModule && !isNodeModule && !request.context.skipCompile)) return [3 /*break*/, 3];
                                return [4 /*yield*/, this.compilePromise];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3: return [3 /*break*/, 6];
                            case 4:
                                err_3 = _a.sent();
                                return [3 /*break*/, 6];
                            case 5:
                                callback();
                                return [7 /*endfinally*/];
                            case 6: return [2 /*return*/];
                        }
                    });
                }); });
            });
        };
        AotPlugin.prototype.calculateEmitPath = function (filePath) {
            var root = this.tsConfig.angularCompilerOptions.basePath;
            for (var _i = 0, _a = this.tsConfig.compilerOptions.rootDirs || []; _i < _a.length; _i++) {
                var eachRootDir = _a[_i];
                if (path.relative(eachRootDir, filePath).indexOf('.') !== 0) {
                    root = eachRootDir;
                }
            }
            var relativePath = path.relative(root, filePath);
            while (relativePath.startsWith('..' + path.sep)) {
                relativePath = relativePath.substr(3);
            }
            return path.join(this.tsConfig.angularCompilerOptions.genDir, relativePath);
        };
        AotPlugin.prototype.compileFiles = function (files, checkDependencies) {
            if (checkDependencies === void 0) { checkDependencies = true; }
            return __awaiter$1(this, void 0, void 0, function () {
                var _this = this;
                function resolveModule(context, path$$1) {
                    return new Promise(function (resolve$$1, reject) {
                        normal.resolve({ skipCompile: true }, context, path$$1, function (err, path$$1, info) {
                            if (err) {
                                return reject(err);
                            }
                            resolve$$1(path$$1);
                        });
                    });
                }
                function loadMetadata(ngModule) {
                    return compiler._metadataResolver
                        .loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
                }
                var normal, _i, files_1, file, sourceFile, loadChildren, _a, loadChildren_1, child, _b, path$$1, module_1, resolvedModule, err_4, compiler, reflector, _c, files_2, file, sourceFiles, _d, sourceFiles_1, sourceFile, symbols, _e, symbols_1, symbol, resolvedSymbol, symbolMetadata, _f, ngModule, filesToCompile, ngModules, cachedItems, _g, filesToCompile_1, analyzedFile, _h, cachedItems_1, item, generatedFiles, _j, filesToCompile_2, file, directives, injectables, ngModules_1, pipes, srcUrl, compiledFile, _loop_1, this_1, _k, generatedFiles_1, generatedFile;
                return __generator$1(this, function (_l) {
                    switch (_l.label) {
                        case 0:
                            normal = this.context.compiler.resolvers.normal;
                            _i = 0, files_1 = files;
                            _l.label = 1;
                        case 1:
                            if (!(_i < files_1.length)) return [3 /*break*/, 8];
                            file = files_1[_i];
                            sourceFile = this.sourceFileCache.get(file);
                            loadChildren = getPropertyAssignments(sourceFile).filter(byPropertyName('loadChildren'));
                            _a = 0, loadChildren_1 = loadChildren;
                            _l.label = 2;
                        case 2:
                            if (!(_a < loadChildren_1.length)) return [3 /*break*/, 7];
                            child = loadChildren_1[_a];
                            _b = getInitializer(child).split('#'), path$$1 = _b[0], module_1 = _b[1];
                            _l.label = 3;
                        case 3:
                            _l.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, resolveModule(path.dirname(file), path$$1)];
                        case 4:
                            resolvedModule = _l.sent();
                            child.initializer.text = resolvedModule + "#" + module_1;
                            return [3 /*break*/, 6];
                        case 5:
                            err_4 = _l.sent();
                            throw err_4;
                        case 6:
                            _a++;
                            return [3 /*break*/, 2];
                        case 7:
                            _i++;
                            return [3 /*break*/, 1];
                        case 8:
                            this.files = this.removeDeletedFiles(filterDuplicates(this.files.concat(files)));
                            compiler = this.aotCompiler.compiler;
                            reflector = this.aotCompiler.reflector;
                            // loop through the changed files and get their canonical file name
                            files = files.map(function (file) { return _this.ngCompilerHost.getCanonicalFileName(file); });
                            // remove any symbols for deleted files
                            this.symbols = this.symbols
                                .filter(function (symbol) { return _this.removeDeletedFiles([symbol.filePath]).length; });
                            // clear the cache for our files
                            for (_c = 0, files_2 = files; _c < files_2.length; _c++) {
                                file = files_2[_c];
                                compiler._summaryResolver.summaryCache.delete(file);
                                compiler._summaryResolver.loadedFilePaths.delete(file);
                                compiler._symbolResolver.metadataCache.delete(file);
                                compiler._symbolResolver.resolvedFilePaths.delete(file);
                            }
                            sourceFiles = files
                                .filter(function (fileName) { return _this.ngCompilerHost.isSourceFile(fileName); });
                            // resolve the symbols for our source files
                            for (_d = 0, sourceFiles_1 = sourceFiles; _d < sourceFiles_1.length; _d++) {
                                sourceFile = sourceFiles_1[_d];
                                symbols = compiler._symbolResolver.getSymbolsOf(sourceFile);
                                for (_e = 0, symbols_1 = symbols; _e < symbols_1.length; _e++) {
                                    symbol = symbols_1[_e];
                                    resolvedSymbol = compiler._symbolResolver.resolveSymbol(symbol);
                                    symbolMetadata = resolvedSymbol.metadata;
                                    if (symbolMetadata && symbolMetadata.__symbolic !== 'error') {
                                        this.symbols.push(resolvedSymbol.symbol);
                                    }
                                }
                            }
                            _f = _angular_compiler.analyzeAndValidateNgModules(this.symbols, this.ngCompilerHost, compiler._metadataResolver), ngModule = _f.ngModuleByPipeOrDirective, filesToCompile = _f.files, ngModules = _f.ngModules;
                            if (this.ranInitialCompile) {
                                // we've already ran the first compilation, so we want to restrict the compilation
                                // to just the changed files, not all files
                                filesToCompile = filesToCompile
                                    .filter(function (file) { return files.includes(file.srcUrl); });
                            }
                            cachedItems = ['directives', 'pipes', 'ngModules'];
                            for (_g = 0, filesToCompile_1 = filesToCompile; _g < filesToCompile_1.length; _g++) {
                                analyzedFile = filesToCompile_1[_g];
                                for (_h = 0, cachedItems_1 = cachedItems; _h < cachedItems_1.length; _h++) {
                                    item = cachedItems_1[_h];
                                    analyzedFile[item].forEach(function (item) {
                                        compiler._metadataResolver.clearCacheFor(item);
                                        reflector.annotationCache.delete(item);
                                        reflector.propertyCache.delete(item);
                                        reflector.parameterCache.delete(item);
                                        reflector.methodCache.delete(item);
                                    });
                                }
                            }
                            // wait for the metadata collection of all the ngModules to complete
                            return [4 /*yield*/, Promise.all(ngModules.map(loadMetadata))];
                        case 9:
                            // wait for the metadata collection of all the ngModules to complete
                            _l.sent();
                            generatedFiles = [];
                            for (_j = 0, filesToCompile_2 = filesToCompile; _j < filesToCompile_2.length; _j++) {
                                file = filesToCompile_2[_j];
                                directives = file.directives, injectables = file.injectables, ngModules_1 = file.ngModules, pipes = file.pipes, srcUrl = file.srcUrl;
                                compiledFile = compiler._compileSrcFile(srcUrl, ngModule, directives, pipes, ngModules_1, injectables);
                                generatedFiles = generatedFiles.concat(compiledFile);
                            }
                            _loop_1 = function (generatedFile) {
                                var genFileUrl, source, srcFileUrl, emitPath, emitFileName, sourceFile, classes, isModule, localDependencies, _i, localDependencies_1, path$$1, dependencies, parentDependencies, shouldCompileDependencies, isComponentDependency, hasComponentDependency;
                                return __generator$1(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            genFileUrl = generatedFile.genFileUrl, source = generatedFile.source, srcFileUrl = generatedFile.srcFileUrl;
                                            emitPath = this_1.calculateEmitPath(genFileUrl);
                                            emitFileName = emitPath.replace(FILE_EXTENSION, '');
                                            if (/ngsummary\.json$/.test(emitPath)) {
                                                return [2 /*return*/, "continue"];
                                            }
                                            sourceFile = typescript.createSourceFile(emitPath, source, typescript.ScriptTarget.Latest);
                                            this_1.sourceFileCache.set(emitPath, sourceFile);
                                            classes = findNodes(sourceFile, typescript.SyntaxKind.ClassDeclaration);
                                            isModule = classes.some(function (declaration) { return INJECTOR.test(declaration.name.text); });
                                            if (!!isModule) return [3 /*break*/, 1];
                                            localDependencies = this_1.findLocalDependencies(sourceFile)
                                                .filter(function (path$$1) { return /ngfactory$/.test(path$$1); })
                                                .map(function (path$$1) { return path.join(path.dirname(emitPath), path$$1); });
                                            for (_i = 0, localDependencies_1 = localDependencies; _i < localDependencies_1.length; _i++) {
                                                path$$1 = localDependencies_1[_i];
                                                if (!this_1.componentDependencies.has(path$$1)) {
                                                    this_1.componentDependencies.set(path$$1, []);
                                                }
                                                dependencies = this_1.componentDependencies.get(path$$1);
                                                if (!dependencies.includes(srcFileUrl)) {
                                                    this_1.componentDependencies.set(path$$1, this_1.removeDeletedFiles(dependencies.concat([srcFileUrl])));
                                                }
                                            }
                                            return [3 /*break*/, 3];
                                        case 1:
                                            parentDependencies = this_1.parentDependencies.get(srcFileUrl);
                                            if (!(parentDependencies && checkDependencies)) return [3 /*break*/, 3];
                                            return [4 /*yield*/, this_1.compileFiles(parentDependencies, false)];
                                        case 2:
                                            _a.sent();
                                            _a.label = 3;
                                        case 3:
                                            shouldCompileDependencies = checkDependencies && this_1.ranInitialCompile;
                                            isComponentDependency = this_1.componentDependencies.has(emitFileName);
                                            hasComponentDependency = this_1.moduleDependencies.has(srcFileUrl);
                                            if (!shouldCompileDependencies) return [3 /*break*/, 7];
                                            if (!isComponentDependency) return [3 /*break*/, 5];
                                            return [4 /*yield*/, this_1.compileFiles(this_1.componentDependencies.get(emitFileName), false)];
                                        case 4:
                                            _a.sent();
                                            _a.label = 5;
                                        case 5:
                                            if (!hasComponentDependency) return [3 /*break*/, 7];
                                            return [4 /*yield*/, this_1.compileFiles(this_1.moduleDependencies.get(srcFileUrl))];
                                        case 6:
                                            _a.sent();
                                            _a.label = 7;
                                        case 7:
                                            this_1.host.writeFile(emitPath, generatedFile.source);
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _k = 0, generatedFiles_1 = generatedFiles;
                            _l.label = 10;
                        case 10:
                            if (!(_k < generatedFiles_1.length)) return [3 /*break*/, 13];
                            generatedFile = generatedFiles_1[_k];
                            return [5 /*yield**/, _loop_1(generatedFile)];
                        case 11:
                            _l.sent();
                            _l.label = 12;
                        case 12:
                            _k++;
                            return [3 /*break*/, 10];
                        case 13: return [2 /*return*/];
                    }
                });
            });
        };
        AotPlugin.prototype.createSourceFiles = function (files, compilation) {
            var fileSystem = compilation.resolvers.normal.fileSystem;
            for (var _i = 0, files_3 = files; _i < files_3.length; _i++) {
                var file = files_3[_i];
                // we cache the source file here as it can be used in multiple places
                var source = fileSystem.readFileSync(file).toString();
                var sourceFile = typescript.createSourceFile(file, source, typescript.ScriptTarget.Latest);
                this.sourceFileCache.set(file, sourceFile);
                var decorators = findNodes(sourceFile, typescript.SyntaxKind.Decorator);
                var isModule = decorators.some(function (decorator) { return getDecorator(decorator) === 'NgModule'; });
                if (isModule) {
                    var _a = this.getModuleDependencies(sourceFile, file), loadChildren = _a.loadChildren, fileDependencies = _a.fileDependencies;
                    this.createSourceFiles(loadChildren, compilation);
                    if (!compilation.fileDependencies) {
                        compilation.fileDependencies = [];
                    }
                    compilation.fileDependencies = compilation.fileDependencies.concat(fileDependencies);
                }
            }
        };
        AotPlugin.prototype.getModuleDependencies = function (sourceFile, file) {
            var _this = this;
            var fileDependencies = [];
            var localDependenciesSearch = this.findLocalDependencies(sourceFile);
            var localDependencies = localDependenciesSearch
                .map(function (path$$1) { return typescript.resolveModuleName(path$$1, file, _this.parsedConfig.options, _this.host); })
                .map(function (resolved, index) {
                if (!resolved.resolvedModule) {
                    throw new Error("Error: " + file + " attempted to import " + localDependenciesSearch[index] + ", but it doesn't exist");
                }
                return resolved.resolvedModule.resolvedFileName;
            });
            for (var _i = 0, localDependencies_2 = localDependencies; _i < localDependencies_2.length; _i++) {
                var path$$1 = localDependencies_2[_i];
                if (!this.moduleDependencies.has(file)) {
                    this.moduleDependencies.set(file, []);
                }
                if (!this.parentDependencies.has(path$$1)) {
                    this.parentDependencies.set(path$$1, []);
                }
                var dependencies = this.moduleDependencies.get(file);
                if (!dependencies.includes(path$$1)) {
                    fileDependencies.push(path$$1);
                    this.moduleDependencies.set(file, this.removeDeletedFiles(dependencies.concat([path$$1])));
                }
                var parentDependencies = this.parentDependencies.get(path$$1);
                if (!parentDependencies.includes(file)) {
                    this.parentDependencies.set(path$$1, this.removeDeletedFiles(parentDependencies.concat([file])));
                }
            }
            var loadChildren = getPropertyAssignments(sourceFile)
                .filter(byPropertyName('loadChildren'))
                .map(function (child) { return getInitializer(child).split('#'); })
                .map(function (_a) {
                var path$$1 = _a[0];
                var resolved = typescript.resolveModuleName(path$$1, file, _this.parsedConfig.options, _this.host);
                if (!resolved.resolvedModule) {
                    throw new Error("Error: " + file + " attempted to import " + path$$1 + ", but it doesn't exist");
                }
                return resolved.resolvedModule.resolvedFileName;
            });
            for (var _a = 0, loadChildren_2 = loadChildren; _a < loadChildren_2.length; _a++) {
                var child = loadChildren_2[_a];
                var dependencies = this.moduleDependencies.get(file);
                if (!dependencies.includes(child)) {
                    fileDependencies.push(child);
                    this.moduleDependencies.set(file, this.removeDeletedFiles(dependencies.concat([child])));
                }
            }
            return { loadChildren: loadChildren, fileDependencies: fileDependencies };
        };
        AotPlugin.prototype.findLocalDependencies = function (sourceFile) {
            return findNodes(sourceFile, typescript.SyntaxKind.ImportDeclaration)
                .map(function (dec) { return getModule(dec); })
                .filter(function (path$$1) { return path$$1.charAt(0) === '.'; });
        };
        AotPlugin.prototype.registerResources = function (from, resources) {
            var dependencies = this.resourcesDependencies.get(from);
            if (dependencies) {
                for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                    var dependency = dependencies_1[_i];
                    if (this.resources.has(dependency)) {
                        var dependencies_2 = this.resources.get(dependency)
                            .filter(function (dependency) { return dependency !== from; });
                        this.resources.set(dependency, this.removeDeletedFiles(dependencies_2));
                    }
                }
            }
            this.resourcesDependencies.set(from, resources.slice());
            for (var _a = 0, resources_1 = resources; _a < resources_1.length; _a++) {
                var resource = resources_1[_a];
                if (!this.resources.has(resource)) {
                    this.resources.set(resource, []);
                }
                var resources_2 = this.resources.get(resource);
                if (!resources_2.includes(from)) {
                    this.resources.set(resource, this.removeDeletedFiles(resources_2.concat([from])));
                }
            }
        };
        AotPlugin.prototype.removeDeletedFiles = function (files) {
            var _this = this;
            return files.filter(function (file) { return _this.host.fileExists(file); });
        };
        return AotPlugin;
    }());

    exports['default'] = aotLoader$1;
    exports.AotPlugin = AotPlugin;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
