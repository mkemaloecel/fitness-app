{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/transform/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  CallExpression,\n  Decorator,\n  Identifier,\n  ImportDeclaration,\n  ImportSpecifier,\n  ModuleName,\n  NamespaceImport,\n  Node,\n  NodeArray,\n  ObjectLiteralElementLike,\n  ObjectLiteralExpression,\n  PropertyAssignment,\n  PropertyDeclaration,\n  QualifiedName,\n  SourceFile,\n  StringLiteral,\n  SyntaxKind,\n  TypeNode,\n  TypeReferenceNode\n} from 'typescript';\n\nexport { NodeArray };\n\nexport function findNodes<T extends Node>(\n  node: Node,\n  kind: SyntaxKind,\n  sourceFile: SourceFile = node as SourceFile,\n  recursive: boolean = false\n): T[] {\n  let nodes: T[] = [];\n  if (node.kind === kind) {\n    if (!recursive) {\n      return [node as T];\n    }\n    nodes.push(node as T);\n  }\n  for (let child of node.getChildren(sourceFile)) {\n    const childNodes = findNodes<T>(child, kind, sourceFile, recursive);\n\n    for (let i = 0; i < childNodes.length; i++) {\n      nodes.push(childNodes[i]);\n    }\n  }\n  return nodes;\n}\n\nexport function filterDuplicates<T>(arr: T[]) {\n  return [...Array.from(new Set<T>(arr))];\n}\n\nexport function flatten<T>(arr: any[]): T[] {\n  return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten<T>(b) : b), []);\n}\n\nexport function getDecorator(node: Decorator) {\n  return ((node.expression as CallExpression).expression as StringLiteral).text;\n}\n\nexport function getLeft(name: QualifiedName) {\n  return (name.left as Identifier).text;\n}\n\nexport function getInitializer(node: PropertyAssignment) {\n  return (node.initializer as StringLiteral).text;\n}\n\nexport function getModule(dec: ImportDeclaration) {\n  return (dec.moduleSpecifier as StringLiteral).text;\n}\n\nexport function getName(node: ImportSpecifier) {\n  return node.propertyName ? node.propertyName.text : node.name.text;\n}\n\nexport function getNamespace(dec: ImportDeclaration) {\n  return (dec.importClause.namedBindings as NamespaceImport).name.text;\n}\n\nexport function getPropertyAssignments(sourceFile: SourceFile) {\n  const properties = findNodes<ObjectLiteralExpression>(sourceFile, SyntaxKind.ObjectLiteralExpression, sourceFile, true)\n    .map((node) => findNodes<PropertyAssignment>(node, SyntaxKind.PropertyAssignment, sourceFile));\n\n  return flatten<PropertyAssignment>(properties);\n}\n\nexport function getRight(name: QualifiedName) {\n  return name.right.text;\n}\n\nexport function getTypeName(type: TypeNode) {\n  return (type as TypeReferenceNode).typeName;\n}\n\nexport function getQualifiedType(type: TypeNode) {\n  return getTypeName(type) as QualifiedName;\n}\n\nexport function getTypeArguments(property: PropertyDeclaration) {\n  return (property.type as TypeReferenceNode).typeArguments;\n}\n\nexport function getTypeText(property: PropertyDeclaration) {\n  return (getTypeName(property.type) as Identifier).text;\n}\n\nexport function normalizePath({text}: StringLiteral) {\n  return (text[0] !== '.' ? `./${text}` : text).replace(/\\/\\//g, '/');\n}\n\nexport function removeUnnamedImports({importClause: c}: ImportDeclaration) {\n  return !(c && !c.name && c.namedBindings) && c.namedBindings.kind === SyntaxKind.NamedImports;\n}\n\nexport function byModule(name: string) {\n  return (dec: ImportDeclaration) => getModule(dec) === name;\n}\n\nexport function byPropertyName(name: string) {\n  return (node: ObjectLiteralElementLike) => (node.name as ModuleName).text === name;\n}\n\nexport function byNamespace(name: string) {\n  return (dec: ImportDeclaration) => getNamespace(dec) === name;\n}\n\nexport function byRightTypeArgument(name: string) {\n  return (type: TypeNode) => getRight(getQualifiedType(type)) === name;\n}\n\nexport function byTypeName(name: string) {\n  return (property: PropertyDeclaration) => getTypeText(property) === name;\n}\n\nexport function objToMap<T>(obj: {[key: string]: T}) {\n  return Object.keys(obj).reduce((a, b) => a.set(b, obj[b]), new Map<string, T>());\n}\n"]}