import { SyntaxKind } from 'typescript';
export function findNodes(node, kind, sourceFile, recursive) {
    if (sourceFile === void 0) { sourceFile = node; }
    if (recursive === void 0) { recursive = false; }
    var nodes = [];
    if (node.kind === kind) {
        if (!recursive) {
            return [node];
        }
        nodes.push(node);
    }
    for (var _i = 0, _a = node.getChildren(sourceFile); _i < _a.length; _i++) {
        var child = _a[_i];
        var childNodes = findNodes(child, kind, sourceFile, recursive);
        for (var i = 0; i < childNodes.length; i++) {
            nodes.push(childNodes[i]);
        }
    }
    return nodes;
}
export function filterDuplicates(arr) {
    return Array.from(new Set(arr)).slice();
}
export function flatten(arr) {
    return arr.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []);
}
export function getDecorator(node) {
    return node.expression.expression.text;
}
export function getLeft(name) {
    return name.left.text;
}
export function getInitializer(node) {
    return node.initializer.text;
}
export function getModule(dec) {
    return dec.moduleSpecifier.text;
}
export function getName(node) {
    return node.propertyName ? node.propertyName.text : node.name.text;
}
export function getNamespace(dec) {
    return dec.importClause.namedBindings.name.text;
}
export function getPropertyAssignments(sourceFile) {
    var properties = findNodes(sourceFile, SyntaxKind.ObjectLiteralExpression, sourceFile, true)
        .map(function (node) { return findNodes(node, SyntaxKind.PropertyAssignment, sourceFile); });
    return flatten(properties);
}
export function getRight(name) {
    return name.right.text;
}
export function getTypeName(type) {
    return type.typeName;
}
export function getQualifiedType(type) {
    return getTypeName(type);
}
export function getTypeArguments(property) {
    return property.type.typeArguments;
}
export function getTypeText(property) {
    return getTypeName(property.type).text;
}
export function normalizePath(_a) {
    var text = _a.text;
    return (text[0] !== '.' ? "./" + text : text).replace(/\/\//g, '/');
}
export function removeUnnamedImports(_a) {
    var c = _a.importClause;
    return !(c && !c.name && c.namedBindings) && c.namedBindings.kind === SyntaxKind.NamedImports;
}
export function byModule(name) {
    return function (dec) { return getModule(dec) === name; };
}
export function byPropertyName(name) {
    return function (node) { return node.name.text === name; };
}
export function byNamespace(name) {
    return function (dec) { return getNamespace(dec) === name; };
}
export function byRightTypeArgument(name) {
    return function (type) { return getRight(getQualifiedType(type)) === name; };
}
export function byTypeName(name) {
    return function (property) { return getTypeText(property) === name; };
}
export function objToMap(obj) {
    return Object.keys(obj).reduce(function (a, b) { return a.set(b, obj[b]); }, new Map());
}
//# sourceMappingURL=utils.js.map