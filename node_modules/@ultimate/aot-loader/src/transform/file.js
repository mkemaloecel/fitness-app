var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import MagicString from 'magic-string';
import { basename, dirname, join, normalize, relative } from 'path';
import { SourceMapConsumer, SourceMapGenerator } from 'source-map';
import { createSourceFile, ScriptTarget, SyntaxKind, transpileModule } from 'typescript';
import { byPropertyName, findNodes, flatten, getInitializer, getModule, getName, getPropertyAssignments, normalizePath, removeUnnamedImports } from './utils';
var loadChildrenTemplate = function (_a) {
    var p = _a[0], m = _a[1];
    return "loadChildren:()=>__TROPMI__('" + p + ".ngfactory').then((r)=>r." + m + "NgFactory)";
};
var EXT = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
var TransformFile = (function () {
    function TransformFile(resourcePath, source, aotPlugin, generateSourceMap, sourceFile) {
        this.resourcePath = resourcePath;
        this.source = source;
        this.aotPlugin = aotPlugin;
        this.generateSourceMap = generateSourceMap;
        this.sourceFile = sourceFile;
        this.edited = false;
        if (!sourceFile) {
            this.sourceFile = createSourceFile(this.resourcePath, this.source, ScriptTarget.Latest);
        }
        this.sourceString = this.sourceFile.getFullText(this.sourceFile);
        this.sourceText = new MagicString(this.sourceString);
    }
    TransformFile.prototype.convertBootstrap = function (moduleName) {
        var _this = this;
        var calls = findNodes(this.sourceFile, SyntaxKind.CallExpression, this.sourceFile, true);
        var bootstraps = calls
            .filter(function (node) { return node.expression.kind === SyntaxKind.PropertyAccessExpression; })
            .map(function (node) { return node.expression; });
        var bootstrappedModules = bootstraps
            .filter(function (expression) { return expression.name.kind === SyntaxKind.Identifier; })
            .filter(function (expression) { return expression.name.text === 'bootstrapModule'; });
        bootstrappedModules.forEach(function (bootstrap) { return _this.replaceNode(bootstrap.name, 'bootstrapModuleFactory'); });
        bootstraps
            .reduce(function (previous, next) { return previous.concat(findNodes(next, SyntaxKind.CallExpression, _this.sourceFile)); }, [])
            .filter(function (call) { return call.expression.kind === SyntaxKind.Identifier; })
            .filter(function (call) { return call.expression.text === 'platformBrowserDynamic'; })
            .forEach(function (call) { return _this.replaceNode(call.expression, 'platformBrowser'); });
        calls
            .filter(function (call) { return bootstrappedModules.some(function (bootstrap) { return bootstrap === call.expression; }); })
            .forEach(function (call) { return _this.replaceNode(call.arguments[0], moduleName + 'NgFactory'); });
    };
    TransformFile.prototype.convertLoadChildren = function (basePath, genDir) {
        var assignments = getPropertyAssignments(this.sourceFile)
            .filter(byPropertyName('loadChildren'));
        for (var _i = 0, assignments_1 = assignments; _i < assignments_1.length; _i++) {
            var node = assignments_1[_i];
            var _a = getInitializer(node).split('#'), path = _a[0], module_1 = _a[1];
            var dirName = normalize(dirname(this.resourcePath));
            var genRelativeToBase = relative(basePath, genDir);
            var fileRelativeToBase = relative(basePath, dirName);
            var genRelativeToFile = relative(fileRelativeToBase, genRelativeToBase);
            var genToFile = join(genRelativeToFile, relative(basePath, path).replace(EXT, ''));
            var factoryPath = './' + genToFile.replace(/\\/g, '/');
            this.replaceNode(node, loadChildrenTemplate([factoryPath, module_1]));
        }
    };
    TransformFile.prototype.convertImport = function (from, to) {
        var imports = findNodes(this.sourceFile, SyntaxKind.ImportDeclaration);
        var fromImports = imports
            .filter(function (dec) { return dec.moduleSpecifier.kind === SyntaxKind.StringLiteral; })
            .filter(function (dec) { return dec.moduleSpecifier.text === from.module; })
            .filter(removeUnnamedImports);
        var needsImport = true;
        if (fromImports.length) {
            for (var i = 0; i < fromImports.length; i++) {
                var fromImport = fromImports[i];
                var namedBindings = fromImport.importClause.namedBindings;
                var elements = namedBindings.elements;
                if (elements.some(function (element) { return element.name.text === from.name; })) {
                    if (elements.length > 1) {
                        var start = 0;
                        var end = 0;
                        for (var n = 0; n < elements.length; n++) {
                            var element = elements[n];
                            if (element.name.text === from.name) {
                                start = (n > 0) ? elements[n - 1].getEnd() : element.getStart(this.sourceFile);
                                end = (n > 0) ? element.getEnd() : elements[n + 1].getStart(this.sourceFile);
                                break;
                            }
                        }
                        this.sourceText.overwrite(start, end, '');
                    }
                    else {
                        needsImport = false;
                        this.replaceNode(fromImport.moduleSpecifier, "'" + to.module + "'");
                        this.replaceNode(elements[0], to.name);
                        break;
                    }
                }
            }
        }
        if (needsImport) {
            var toImports = imports
                .filter(function (dec) { return dec.moduleSpecifier.kind === SyntaxKind.StringLiteral; })
                .filter(function (dec) { return dec.moduleSpecifier.text === to.module; })
                .filter(removeUnnamedImports);
            if (toImports.length) {
                for (var i = 0; i < toImports.length; i++) {
                    var toImport = toImports[i];
                    var namedBindings = toImport.importClause.namedBindings;
                    var elements = namedBindings.elements;
                    var hasImport = elements.some(function (element) { return element.name.text === to.name; });
                    if (hasImport) {
                        break;
                    }
                    this.sourceText.prependRight(elements[elements.length - 1].getEnd(), ", " + to.name);
                }
            }
            else {
                this.sourceText.prependRight(imports[imports.length - 1].getEnd(), "import {" + to.name + "} from '" + to.module + "';");
            }
        }
    };
    TransformFile.prototype.getResources = function () {
        var properties = getPropertyAssignments(this.sourceFile);
        var resources = [];
        var styleUrlsProperty = properties.find(byPropertyName('styleUrls'));
        if (styleUrlsProperty) {
            resources = resources.concat(styleUrlsProperty.initializer.elements);
        }
        var templateUrlProperty = properties.find(byPropertyName('templateUrl'));
        if (templateUrlProperty) {
            resources.push(templateUrlProperty.initializer);
        }
        return resources.map(normalizePath);
    };
    TransformFile.prototype.removeDecorators = function () {
        var imports = findNodes(this.sourceFile, SyntaxKind.ImportDeclaration)
            .filter(function (node) { return node.moduleSpecifier.kind === SyntaxKind.StringLiteral; })
            .filter(function (node) { return getModule(node).startsWith('@angular/'); })
            .filter(function (node) { return node.importClause && !node.importClause.name && node.importClause.namedBindings; })
            .map(function (node) { return node.importClause.namedBindings; });
        var namespaceImports = imports
            .filter(function (node) { return node.kind === SyntaxKind.NamespaceImport; })
            .map(function (node) { return node.name.text + '.'; });
        var namedImports = imports
            .filter(function (node) { return node.kind === SyntaxKind.NamedImports; })
            .map(function (node) { return node.elements; })
            .map(function (elements) { return elements.map(getName); });
        var angularImports = flatten(namedImports.concat(namespaceImports));
        if (!angularImports.length) {
            return;
        }
        function isAngularImport(node) {
            var decorator = node.expression.text;
            if (decorator.includes('.')) {
                return angularImports.includes(decorator.replace(/\..*$/, '') + '.');
            }
            return angularImports.includes(decorator);
        }
        var decorators = findNodes(this.sourceFile, SyntaxKind.Decorator);
        for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
            var node = decorators_1[_i];
            var expressions = findNodes(node, SyntaxKind.CallExpression).filter(isAngularImport);
            for (var _a = 0, expressions_1 = expressions; _a < expressions_1.length; _a++) {
                var expr = expressions_1[_a];
                this.removeNode(node);
            }
        }
    };
    TransformFile.prototype.removeNode = function (node) {
        this.edited = true;
        this.sourceText.remove(node.getStart(this.sourceFile), node.getEnd());
    };
    TransformFile.prototype.replaceNode = function (node, contents) {
        this.edited = true;
        var store = node.kind === SyntaxKind.Identifier;
        this.sourceText.overwrite(node.getStart(this.sourceFile), node.getEnd(), contents, store);
    };
    TransformFile.prototype.transpile = function () {
        var result = transpileModule(this.sourceText.toString(), {
            compilerOptions: __assign({}, this.aotPlugin.parsedConfig.options, { inlineSources: true, inlineSourceMap: false, sourceMap: true, sourceRoot: this.aotPlugin.parsedConfig.options.baseUrl }),
            fileName: this.resourcePath
        });
        var sourceMap = JSON.parse(result.sourceMapText);
        if (this.edited && this.generateSourceMap) {
            var consumer = new SourceMapConsumer(sourceMap);
            var generator = SourceMapGenerator.fromSourceMap(consumer);
            var textSourceMap = this.sourceText.generateMap({
                file: basename(this.resourcePath.replace(/\.ts$/, '.js')),
                source: this.resourcePath,
                includeAll: true
            });
            generator.applySourceMap(new SourceMapConsumer(textSourceMap), this.resourcePath);
            sourceMap = generator.toJSON();
            sourceMap.sources = [this.resourcePath];
            sourceMap.file = basename(this.resourcePath, '.ts') + '.js';
            sourceMap.sourcesContent = [this.sourceString];
        }
        return {
            outputText: result.outputText,
            sourceMap: sourceMap
        };
    };
    return TransformFile;
}());
export { TransformFile };
//# sourceMappingURL=file.js.map