var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { extname, dirname, join, relative, resolve, sep } from 'path';
import { analyzeAndValidateNgModules, createAotCompiler } from '@angular/compiler';
import { createProgram, createSourceFile, resolveModuleName, parseJsonConfigFileContent, ScriptTarget, SyntaxKind, sys } from 'typescript';
import { byPropertyName, filterDuplicates, findNodes, getDecorator, getInitializer, getModule, getPropertyAssignments, objToMap } from './transform/utils';
import { Host } from './host';
import { AotContext } from './context';
import { AotCompilerHost } from './compiler';
var FILE_EXTENSION = /\.[^/.]+$/;
var INJECTOR = /(\w+?)Injector/;
var AotPlugin = (function () {
    function AotPlugin(config) {
        this.config = config;
        this.files = [];
        // dependencies
        this.componentDependencies = new Map();
        this.moduleDependencies = new Map();
        this.parentDependencies = new Map();
        // misc
        this.compilePromise = Promise.resolve();
        this.ranInitialCompile = false;
        // timing
        this.prevTimestamps = new Map();
        this.startTime = Date.now();
        // resources
        this.resources = new Map();
        this.resourcesDependencies = new Map();
        // cache
        this.sourceFileCache = new Map();
        this.symbols = [];
        if (!config.tsConfig) {
            throw new Error('tsconfig.json is required');
        }
        var tsConfigPath = resolve(process.cwd(), config.tsConfig);
        try {
            this.tsConfig = JSON.parse(sys.readFile(tsConfigPath));
        }
        catch (err) {
            throw new Error("Error parsing tsconfig.json: " + err);
        }
        this.parsedConfig = parseJsonConfigFileContent(this.tsConfig, sys, dirname(tsConfigPath), null, tsConfigPath);
        var angularCompilerOptions = this.tsConfig.angularCompilerOptions || {};
        angularCompilerOptions.basePath = angularCompilerOptions.basePath || dirname(tsConfigPath);
        angularCompilerOptions.genDir = join(angularCompilerOptions.basePath, angularCompilerOptions.genDir || '__generated');
        if (config.entryModule) {
            angularCompilerOptions.entryModule = config.entryModule;
        }
        this.tsConfig.angularCompilerOptions = angularCompilerOptions;
        var _a = angularCompilerOptions.entryModule.split('#'), path = _a[0], module = _a[1];
        this.entryModule = { path: path, module: module };
        this.host = new Host(this.parsedConfig.options, angularCompilerOptions.basePath);
        this.context = new AotContext(this.host);
        this.program = createProgram(this.parsedConfig.fileNames, this.parsedConfig.options, this.host, this.program);
        this.ngCompilerHost = new AotCompilerHost(this.program, angularCompilerOptions, this.context, this.sourceFileCache);
        this.aotCompiler = createAotCompiler(this.ngCompilerHost, {});
    }
    AotPlugin.prototype.apply = function (compiler) {
        var _this = this;
        this.context.compiler = compiler;
        this.host.compiler = compiler;
        // compiler.watchFileSystem.watcher
        var errors = [];
        compiler.plugin('make', function (compilation, callback) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            var err_1, changedFiles, extraFiles, _i, changedFiles_1, changedFile, files, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        errors = [];
                        compilation.aotPlugin = this;
                        this.context.compilation = compilation;
                        this.host.compilation = compilation;
                        if (!!this.ranInitialCompile) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        this.createSourceFiles(this.parsedConfig.fileNames, compilation);
                        this.compilePromise = this.compileFiles(this.parsedConfig.fileNames);
                        return [4 /*yield*/, this.compilePromise];
                    case 2:
                        _a.sent();
                        this.ranInitialCompile = true;
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        errors.push(err_1);
                        return [3 /*break*/, 4];
                    case 4:
                        changedFiles = Object.keys(compilation.fileTimestamps)
                            .filter(function (file) { return (_this.prevTimestamps.get(file) || _this.startTime) < (compilation.fileTimestamps[file] || Infinity); });
                        extraFiles = [];
                        for (_i = 0, changedFiles_1 = changedFiles; _i < changedFiles_1.length; _i++) {
                            changedFile = changedFiles_1[_i];
                            if (this.resources.has(changedFile)) {
                                extraFiles = filterDuplicates(extraFiles.concat(this.resources.get(changedFile)));
                            }
                        }
                        changedFiles = changedFiles
                            .filter(function (file) { return !_this.resources.has(file); })
                            .concat(extraFiles);
                        this.prevTimestamps = new Map(objToMap(compilation.fileTimestamps));
                        files = changedFiles.length ? changedFiles : this.parsedConfig.fileNames;
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 8, , 9]);
                        this.createSourceFiles(files, compilation);
                        if (!changedFiles.length) return [3 /*break*/, 7];
                        // compile files if we've got newly updated files
                        this.compilePromise = this.compileFiles(changedFiles);
                        return [4 /*yield*/, this.compilePromise];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        err_2 = _a.sent();
                        errors.push(err_2);
                        return [3 /*break*/, 9];
                    case 9:
                        callback();
                        return [2 /*return*/];
                }
            });
        }); });
        compiler.plugin('after-emit', function (compilation, callback) {
            if (errors.length) {
                // add files to the file dependencies so webpack watches them
                compilation.fileDependencies = compilation.fileDependencies.concat(_this.files);
                compilation.errors = compilation.errors.concat(errors);
            }
            callback();
        });
        compiler.plugin('after-resolvers', function (compiler) {
            compiler.resolvers.normal.plugin('before-resolve', function (request, callback) { return __awaiter(_this, void 0, void 0, function () {
                var requestExtension, isNativeModule, isNodeModule, isResource, isCompiling, err_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            requestExtension = extname(request.request);
                            isNativeModule = request.request.charAt(0) !== '.';
                            isNodeModule = /node_modules/.test(request.request);
                            isResource = this.context.resourceExtensions.includes(requestExtension);
                            isCompiling = this.context.compiling;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 4, 5, 6]);
                            if (!(!isCompiling && !isResource && !isNativeModule && !isNodeModule && !request.context.skipCompile)) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.compilePromise];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [3 /*break*/, 6];
                        case 4:
                            err_3 = _a.sent();
                            return [3 /*break*/, 6];
                        case 5:
                            callback();
                            return [7 /*endfinally*/];
                        case 6: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    AotPlugin.prototype.calculateEmitPath = function (filePath) {
        var root = this.tsConfig.angularCompilerOptions.basePath;
        for (var _i = 0, _a = this.tsConfig.compilerOptions.rootDirs || []; _i < _a.length; _i++) {
            var eachRootDir = _a[_i];
            if (relative(eachRootDir, filePath).indexOf('.') !== 0) {
                root = eachRootDir;
            }
        }
        var relativePath = relative(root, filePath);
        while (relativePath.startsWith('..' + sep)) {
            relativePath = relativePath.substr(3);
        }
        return join(this.tsConfig.angularCompilerOptions.genDir, relativePath);
    };
    AotPlugin.prototype.compileFiles = function (files, checkDependencies) {
        if (checkDependencies === void 0) { checkDependencies = true; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            function resolveModule(context, path) {
                return new Promise(function (resolve, reject) {
                    normal.resolve({ skipCompile: true }, context, path, function (err, path, info) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(path);
                    });
                });
            }
            function loadMetadata(ngModule) {
                return compiler._metadataResolver
                    .loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);
            }
            var normal, _i, files_1, file, sourceFile, loadChildren, _a, loadChildren_1, child, _b, path, module_1, resolvedModule, err_4, compiler, reflector, _c, files_2, file, sourceFiles, _d, sourceFiles_1, sourceFile, symbols, _e, symbols_1, symbol, resolvedSymbol, symbolMetadata, _f, ngModule, filesToCompile, ngModules, cachedItems, _g, filesToCompile_1, analyzedFile, _h, cachedItems_1, item, generatedFiles, _j, filesToCompile_2, file, directives, injectables, ngModules_1, pipes, srcUrl, compiledFile, _loop_1, this_1, _k, generatedFiles_1, generatedFile;
            return __generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        normal = this.context.compiler.resolvers.normal;
                        _i = 0, files_1 = files;
                        _l.label = 1;
                    case 1:
                        if (!(_i < files_1.length)) return [3 /*break*/, 8];
                        file = files_1[_i];
                        sourceFile = this.sourceFileCache.get(file);
                        loadChildren = getPropertyAssignments(sourceFile).filter(byPropertyName('loadChildren'));
                        _a = 0, loadChildren_1 = loadChildren;
                        _l.label = 2;
                    case 2:
                        if (!(_a < loadChildren_1.length)) return [3 /*break*/, 7];
                        child = loadChildren_1[_a];
                        _b = getInitializer(child).split('#'), path = _b[0], module_1 = _b[1];
                        _l.label = 3;
                    case 3:
                        _l.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, resolveModule(dirname(file), path)];
                    case 4:
                        resolvedModule = _l.sent();
                        child.initializer.text = resolvedModule + "#" + module_1;
                        return [3 /*break*/, 6];
                    case 5:
                        err_4 = _l.sent();
                        throw err_4;
                    case 6:
                        _a++;
                        return [3 /*break*/, 2];
                    case 7:
                        _i++;
                        return [3 /*break*/, 1];
                    case 8:
                        this.files = this.removeDeletedFiles(filterDuplicates(this.files.concat(files)));
                        compiler = this.aotCompiler.compiler;
                        reflector = this.aotCompiler.reflector;
                        // loop through the changed files and get their canonical file name
                        files = files.map(function (file) { return _this.ngCompilerHost.getCanonicalFileName(file); });
                        // remove any symbols for deleted files
                        this.symbols = this.symbols
                            .filter(function (symbol) { return _this.removeDeletedFiles([symbol.filePath]).length; });
                        // clear the cache for our files
                        for (_c = 0, files_2 = files; _c < files_2.length; _c++) {
                            file = files_2[_c];
                            compiler._summaryResolver.summaryCache.delete(file);
                            compiler._summaryResolver.loadedFilePaths.delete(file);
                            compiler._symbolResolver.metadataCache.delete(file);
                            compiler._symbolResolver.resolvedFilePaths.delete(file);
                        }
                        sourceFiles = files
                            .filter(function (fileName) { return _this.ngCompilerHost.isSourceFile(fileName); });
                        // resolve the symbols for our source files
                        for (_d = 0, sourceFiles_1 = sourceFiles; _d < sourceFiles_1.length; _d++) {
                            sourceFile = sourceFiles_1[_d];
                            symbols = compiler._symbolResolver.getSymbolsOf(sourceFile);
                            for (_e = 0, symbols_1 = symbols; _e < symbols_1.length; _e++) {
                                symbol = symbols_1[_e];
                                resolvedSymbol = compiler._symbolResolver.resolveSymbol(symbol);
                                symbolMetadata = resolvedSymbol.metadata;
                                if (symbolMetadata && symbolMetadata.__symbolic !== 'error') {
                                    this.symbols.push(resolvedSymbol.symbol);
                                }
                            }
                        }
                        _f = analyzeAndValidateNgModules(this.symbols, this.ngCompilerHost, compiler._metadataResolver), ngModule = _f.ngModuleByPipeOrDirective, filesToCompile = _f.files, ngModules = _f.ngModules;
                        if (this.ranInitialCompile) {
                            // we've already ran the first compilation, so we want to restrict the compilation
                            // to just the changed files, not all files
                            filesToCompile = filesToCompile
                                .filter(function (file) { return files.includes(file.srcUrl); });
                        }
                        cachedItems = ['directives', 'pipes', 'ngModules'];
                        for (_g = 0, filesToCompile_1 = filesToCompile; _g < filesToCompile_1.length; _g++) {
                            analyzedFile = filesToCompile_1[_g];
                            for (_h = 0, cachedItems_1 = cachedItems; _h < cachedItems_1.length; _h++) {
                                item = cachedItems_1[_h];
                                analyzedFile[item].forEach(function (item) {
                                    compiler._metadataResolver.clearCacheFor(item);
                                    reflector.annotationCache.delete(item);
                                    reflector.propertyCache.delete(item);
                                    reflector.parameterCache.delete(item);
                                    reflector.methodCache.delete(item);
                                });
                            }
                        }
                        // wait for the metadata collection of all the ngModules to complete
                        return [4 /*yield*/, Promise.all(ngModules.map(loadMetadata))];
                    case 9:
                        // wait for the metadata collection of all the ngModules to complete
                        _l.sent();
                        generatedFiles = [];
                        for (_j = 0, filesToCompile_2 = filesToCompile; _j < filesToCompile_2.length; _j++) {
                            file = filesToCompile_2[_j];
                            directives = file.directives, injectables = file.injectables, ngModules_1 = file.ngModules, pipes = file.pipes, srcUrl = file.srcUrl;
                            compiledFile = compiler._compileSrcFile(srcUrl, ngModule, directives, pipes, ngModules_1, injectables);
                            generatedFiles = generatedFiles.concat(compiledFile);
                        }
                        _loop_1 = function (generatedFile) {
                            var genFileUrl, source, srcFileUrl, emitPath, emitFileName, sourceFile, classes, isModule, localDependencies, _i, localDependencies_1, path, dependencies, parentDependencies, shouldCompileDependencies, isComponentDependency, hasComponentDependency;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        genFileUrl = generatedFile.genFileUrl, source = generatedFile.source, srcFileUrl = generatedFile.srcFileUrl;
                                        emitPath = this_1.calculateEmitPath(genFileUrl);
                                        emitFileName = emitPath.replace(FILE_EXTENSION, '');
                                        if (/ngsummary\.json$/.test(emitPath)) {
                                            return [2 /*return*/, "continue"];
                                        }
                                        sourceFile = createSourceFile(emitPath, source, ScriptTarget.Latest);
                                        this_1.sourceFileCache.set(emitPath, sourceFile);
                                        classes = findNodes(sourceFile, SyntaxKind.ClassDeclaration);
                                        isModule = classes.some(function (declaration) { return INJECTOR.test(declaration.name.text); });
                                        if (!!isModule) return [3 /*break*/, 1];
                                        localDependencies = this_1.findLocalDependencies(sourceFile)
                                            .filter(function (path) { return /ngfactory$/.test(path); })
                                            .map(function (path) { return join(dirname(emitPath), path); });
                                        for (_i = 0, localDependencies_1 = localDependencies; _i < localDependencies_1.length; _i++) {
                                            path = localDependencies_1[_i];
                                            if (!this_1.componentDependencies.has(path)) {
                                                this_1.componentDependencies.set(path, []);
                                            }
                                            dependencies = this_1.componentDependencies.get(path);
                                            if (!dependencies.includes(srcFileUrl)) {
                                                this_1.componentDependencies.set(path, this_1.removeDeletedFiles(dependencies.concat([srcFileUrl])));
                                            }
                                        }
                                        return [3 /*break*/, 3];
                                    case 1:
                                        parentDependencies = this_1.parentDependencies.get(srcFileUrl);
                                        if (!(parentDependencies && checkDependencies)) return [3 /*break*/, 3];
                                        return [4 /*yield*/, this_1.compileFiles(parentDependencies, false)];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3:
                                        shouldCompileDependencies = checkDependencies && this_1.ranInitialCompile;
                                        isComponentDependency = this_1.componentDependencies.has(emitFileName);
                                        hasComponentDependency = this_1.moduleDependencies.has(srcFileUrl);
                                        if (!shouldCompileDependencies) return [3 /*break*/, 7];
                                        if (!isComponentDependency) return [3 /*break*/, 5];
                                        return [4 /*yield*/, this_1.compileFiles(this_1.componentDependencies.get(emitFileName), false)];
                                    case 4:
                                        _a.sent();
                                        _a.label = 5;
                                    case 5:
                                        if (!hasComponentDependency) return [3 /*break*/, 7];
                                        return [4 /*yield*/, this_1.compileFiles(this_1.moduleDependencies.get(srcFileUrl))];
                                    case 6:
                                        _a.sent();
                                        _a.label = 7;
                                    case 7:
                                        this_1.host.writeFile(emitPath, generatedFile.source);
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _k = 0, generatedFiles_1 = generatedFiles;
                        _l.label = 10;
                    case 10:
                        if (!(_k < generatedFiles_1.length)) return [3 /*break*/, 13];
                        generatedFile = generatedFiles_1[_k];
                        return [5 /*yield**/, _loop_1(generatedFile)];
                    case 11:
                        _l.sent();
                        _l.label = 12;
                    case 12:
                        _k++;
                        return [3 /*break*/, 10];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    AotPlugin.prototype.createSourceFiles = function (files, compilation) {
        var fileSystem = compilation.resolvers.normal.fileSystem;
        for (var _i = 0, files_3 = files; _i < files_3.length; _i++) {
            var file = files_3[_i];
            // we cache the source file here as it can be used in multiple places
            var source = fileSystem.readFileSync(file).toString();
            var sourceFile = createSourceFile(file, source, ScriptTarget.Latest);
            this.sourceFileCache.set(file, sourceFile);
            var decorators = findNodes(sourceFile, SyntaxKind.Decorator);
            var isModule = decorators.some(function (decorator) { return getDecorator(decorator) === 'NgModule'; });
            if (isModule) {
                var _a = this.getModuleDependencies(sourceFile, file), loadChildren = _a.loadChildren, fileDependencies = _a.fileDependencies;
                this.createSourceFiles(loadChildren, compilation);
                if (!compilation.fileDependencies) {
                    compilation.fileDependencies = [];
                }
                compilation.fileDependencies = compilation.fileDependencies.concat(fileDependencies);
            }
        }
    };
    AotPlugin.prototype.getModuleDependencies = function (sourceFile, file) {
        var _this = this;
        var fileDependencies = [];
        var localDependenciesSearch = this.findLocalDependencies(sourceFile);
        var localDependencies = localDependenciesSearch
            .map(function (path) { return resolveModuleName(path, file, _this.parsedConfig.options, _this.host); })
            .map(function (resolved, index) {
            if (!resolved.resolvedModule) {
                throw new Error("Error: " + file + " attempted to import " + localDependenciesSearch[index] + ", but it doesn't exist");
            }
            return resolved.resolvedModule.resolvedFileName;
        });
        for (var _i = 0, localDependencies_2 = localDependencies; _i < localDependencies_2.length; _i++) {
            var path = localDependencies_2[_i];
            if (!this.moduleDependencies.has(file)) {
                this.moduleDependencies.set(file, []);
            }
            if (!this.parentDependencies.has(path)) {
                this.parentDependencies.set(path, []);
            }
            var dependencies = this.moduleDependencies.get(file);
            if (!dependencies.includes(path)) {
                fileDependencies.push(path);
                this.moduleDependencies.set(file, this.removeDeletedFiles(dependencies.concat([path])));
            }
            var parentDependencies = this.parentDependencies.get(path);
            if (!parentDependencies.includes(file)) {
                this.parentDependencies.set(path, this.removeDeletedFiles(parentDependencies.concat([file])));
            }
        }
        var loadChildren = getPropertyAssignments(sourceFile)
            .filter(byPropertyName('loadChildren'))
            .map(function (child) { return getInitializer(child).split('#'); })
            .map(function (_a) {
            var path = _a[0];
            var resolved = resolveModuleName(path, file, _this.parsedConfig.options, _this.host);
            if (!resolved.resolvedModule) {
                throw new Error("Error: " + file + " attempted to import " + path + ", but it doesn't exist");
            }
            return resolved.resolvedModule.resolvedFileName;
        });
        for (var _a = 0, loadChildren_2 = loadChildren; _a < loadChildren_2.length; _a++) {
            var child = loadChildren_2[_a];
            var dependencies = this.moduleDependencies.get(file);
            if (!dependencies.includes(child)) {
                fileDependencies.push(child);
                this.moduleDependencies.set(file, this.removeDeletedFiles(dependencies.concat([child])));
            }
        }
        return { loadChildren: loadChildren, fileDependencies: fileDependencies };
    };
    AotPlugin.prototype.findLocalDependencies = function (sourceFile) {
        return findNodes(sourceFile, SyntaxKind.ImportDeclaration)
            .map(function (dec) { return getModule(dec); })
            .filter(function (path) { return path.charAt(0) === '.'; });
    };
    AotPlugin.prototype.registerResources = function (from, resources) {
        var dependencies = this.resourcesDependencies.get(from);
        if (dependencies) {
            for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                var dependency = dependencies_1[_i];
                if (this.resources.has(dependency)) {
                    var dependencies_2 = this.resources.get(dependency)
                        .filter(function (dependency) { return dependency !== from; });
                    this.resources.set(dependency, this.removeDeletedFiles(dependencies_2));
                }
            }
        }
        this.resourcesDependencies.set(from, resources.slice());
        for (var _a = 0, resources_1 = resources; _a < resources_1.length; _a++) {
            var resource = resources_1[_a];
            if (!this.resources.has(resource)) {
                this.resources.set(resource, []);
            }
            var resources_2 = this.resources.get(resource);
            if (!resources_2.includes(from)) {
                this.resources.set(resource, this.removeDeletedFiles(resources_2.concat([from])));
            }
        }
    };
    AotPlugin.prototype.removeDeletedFiles = function (files) {
        var _this = this;
        return files.filter(function (file) { return _this.host.fileExists(file); });
    };
    return AotPlugin;
}());
export { AotPlugin };
//# sourceMappingURL=plugin.js.map